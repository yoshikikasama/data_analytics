# ビッグデータ分析・活用のためのSQLレシピ

## 概要

このアーカイブに含まれるファイルは、『ビッグデータ分析・活用のためのSQLレシピ』（マイナビ出版）に掲載されている各種テーブル定義など、サンプルデータです。

「Chapter3」〜「Chapter8」までのフォルダに、各章内で使用するサンプルデータを項別に配置しています（Chapter1とChapter2、Chapter9のサンプルデータはありません）。同一のテーブルを別の項で使用する場合でも、項ごとに動作確認ができるように重複してデータを保持しています。

なお、ここで提供するデータは本書で紹介するクエリを動作確認するためのダミーデータであるため、本書内での出力結果とは必ずしも一致しません。予めご了承ください。

## MEMO

- GROUP BY
  - SELECT句に指定できるカラムはGROUP BY句に指定したカラムか集約関数(SUM,COUNT,AVG..)のみ。
  - GROUP BY句を使用したクエリでは、GROUP BY句に指定したカラムをユニークキーとして、新たなテーブルが作られます。その過程でGROUP BY句に指定していないカラムの値は失われるため。

- ウィンドウ関数の基本構成
  - テーブルの中でウィンドウと呼ばれるある種の範囲を定義し、その範囲内に含まれる値を特定のレコードから自由に利用できるように定義したもの。
- ウィンドウ関数の基本的な形は以下のようになります：

```sql
  関数名(列名) OVER (PARTITION BY 列名 ORDER BY 列名)
```

- OVER キーワードを使って、どの範囲で集約や計算を行うかを指定します。
- PARTITION BY: データを特定の範囲（パーティション）に分けて処理します。たとえば user_id でパーティションを分ければ、ユーザーごとに計算を行います。
- ORDER BY: パーティション内での並び順を指定します。これがあると、ランキング関数なども使えます。
- ウィンドウ関数の例
  - 以下、ウィンドウ関数を使って平均スコアをユーザーごとに計算する例です。

```sql
SELECT
    user_id,
    score,
    AVG(score) OVER (PARTITION BY user_id) AS user_avg_score
FROM
    review;
```

- このクエリは次のことをしています：
  - PARTITION BY user_id で、ユーザーごとにデータを分けています。
  - AVG(score) は、各ユーザーの平均スコアを計算します。
  - 結果として、user_id が同じ行すべてに同じ user_avg_score が表示されます。
  - なぜウィンドウ関数が便利か？
    - 通常、集約関数を使うと GROUP BY と一緒に使う必要があり、データが「グループ化」されてしまいます。そのため、詳細な行データを失うことがあります。ウィンドウ関数を使えば、各行に対して集約データ（たとえば平均値など）を「そのまま」表示できるので、元のデータと集約結果を同時に扱えます。

- ROWS BETWEEN ... AND ...
  - ウィンドウ関数の集計範囲を指定するために使います。ウィンドウ関数が適用される際に、「どの範囲のデータを含めて計算するか」を制御できます。
  - ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  - 意味: 最初の行から現在の行までのすべての行を範囲に含む。
  - 用途: 累積計算（例えば、現在の行までの累積合計や累積平均）に便利です。
- UNBOUNDED PRECEDING
  - 「無限に前の行」＝つまり、テーブルの最初の行から
- UNBOUNDED FOLLOWING
  - 「無限に後の行」＝つまり、テーブルの最後の行まで。
- n PRECEDING
  - n行前
- n FOLLOWING
  - n行後
- 

### コード3.3.4.8：ピボットテーブルを用いて文字列を行に展開するクエリ

わかりやすく言うと、このクエリは「`product_ids` に含まれる商品の数だけ行を作りたい」のですが、そのために「商品の数より多い行は作らないように制限している」ということです。

具体的に説明します。

---

### 例として、`product_ids` が `"123,456,789"` の場合を考えます

この `product_ids` には、3つの商品ID（123、456、789）が含まれています。この場合、クエリは以下のように3行を作りたいです：

| purchase_id | product_ids | idx | product_id |
| ----------- | ----------- | --- | ---------- |
| 1           | 123,456,789 | 1   | 123        |
| 1           | 123,456,789 | 2   | 456        |
| 1           | 123,456,789 | 3   | 789        |

このためには、「3つの行だけ」作ればいいので、`idx`（インデックス）が1から3までの範囲であれば良いわけです。

### クエリの仕組み

クエリはまず、「1から3の連番を持つテーブル」を作ります。これが次の部分です：

```sql
(
    SELECT 1 AS idx
    UNION ALL SELECT 2 AS idx
    UNION ALL SELECT 3 AS idx
) AS p
```

この部分で作られたテーブル `p` は、次のような行を持っています：

| idx |
| --- |
| 1   |
| 2   |
| 3   |

次に、これと `purchase_log` テーブルを結合することで、`idx` が 1、2、3 の行と `product_ids` を組み合わせて商品IDを抽出します。

### 条件付き結合

しかし、`product_ids` の商品数がいつも3つとは限りません。たとえば、`product_ids` が `"987,654"` の場合、商品数は2つです。このときは `idx` が1と2だけの2行だけを作りたいので、`idx` が 3 の行は結合しないように制限をかけます。

そのために、以下の条件を使って「商品の数より多い行は作らないように」制限しています：

```sql
ON p.idx <= (1 + char_length(l.product_ids) - char_length(replace(l.product_ids, ',', '')))
```

この部分の計算 `(1 + char_length(l.product_ids) - char_length(replace(l.product_ids, ',', '')))` は、「`product_ids` に含まれる商品数」を表しています。カンマの数に1を足すことで、商品がいくつあるかを求めています。

### まとめると

- `product_ids` の商品数が3なら、`idx` は1から3までの行が結合される
- `product_ids` の商品数が2なら、`idx` は1と2だけが結合される

このようにして、`product_ids` に含まれる商品の数に応じて行数が決まるようになっています。

SQLでは、データを行から列に変換する「ピボット操作」と、列から行に変換する「アンピボット操作」の両方が行われます。このクエリで行っているのは、「アンピボット」操作です。

